axis.title.y = element_text(size = 16),
axis.text.x = element_text(size = 16),
axis.text.y = element_text(size = 16))
##Median Income/Poverty##
#pull income from ACS
median_income <-
get_acs(
geography = "tract",
table = "B19013",
state = state_fips,
county = county_fips,
year = 2023,
survey = "acs5",
geometry = TRUE
)
#edit the table so that each row is a census tract
income_wide_pico <- median_income %>%
filter(variable == "B19013_001", GEOID %in% pico_tracts$GEOID) %>%
mutate(income = estimate) %>%
select(GEOID, income, NAME, moe, geometry)
income_map_pico <- ggplot(income_wide_pico) +
geom_sf(aes(fill = income), show.legend = TRUE) +
geom_sf(data = pico_buffer_tracts, color = "yellow", alpha = 0.2, lwd = 1) +
geom_sf(data = major_streets_clipped, color = "gray20", size = 0.3) +
scale_fill_gradientn(
colors = palette_urbn_green[c(1,2,4,6,8)],
name = "Median Income by Census Tract",
labels = scales::label_dollar(scale_cut = scales::cut_short_scale())
) +
theme_urbn_map() +
theme(
legend.title = element_text(size = 16),
legend.text = element_text(size = 16),
legend.key.height = unit(1.2, "cm"),
legend.key.width = unit(0.6, "cm")
)
#edit table so that each row is a census tract and we can calculate the share
poverty_wide_pico <- poverty_level %>%
filter(variable %in% c("B17001_001", "B17001_002"),
GEOID %in% pico_tracts$GEOID) %>%
select(GEOID, variable, estimate, geometry) %>%
pivot_wider(names_from = variable, values_from = estimate) %>%
mutate(
pct_below_pov = 100 * B17001_002 / B17001_001,
pov_bin = case_when(
pct_below_pov < 10 ~ "Less than 10%",
pct_below_pov >= 10 & pct_below_pov < 20 ~ "10–20%",
pct_below_pov >= 20 & pct_below_pov < 30 ~ "20–30%",
pct_below_pov >= 30 ~ "30% or more",
TRUE ~ NA_character_
),
pov_bin = factor(pov_bin, levels = c("Less than 10%", "10–20%", "20–30%", "30% or more"))
)%>%
rename(
total_pop = B17001_001,
below_pov = B17001_002
) %>%
select(GEOID, total_pop, below_pov, pct_below_pov, pov_bin, geometry)
sum(poverty_wide_pico$below_pov)
total_share_below_pov <- sum(poverty_wide_pico$below_pov, na.rm = TRUE) / sum(poverty_wide_pico$total_pop, na.rm = TRUE)
#Map of tracts by poverty level status
poverty_map_pico <- ggplot(poverty_wide_pico) +
geom_sf(aes(fill = pov_bin), show.legend = TRUE) +
geom_sf(data = pico_buffer_tracts, color = "yellow", alpha = 0.2, lwd = 1) +
geom_sf(data = major_streets_clipped, color = "gray20", size = 0.3) +
scale_fill_manual(
values = c(
"Less than 10%" = "#d0f0c0",
"10–20%" = "#a1d99b",
"20–30%" = "#74c476",
"30% or more" = "#238b45"
),
name = "Share Below Poverty",
drop = FALSE
) +
theme_urbn_map() +
theme(
legend.title = element_text(size = 16),
legend.text = element_text(size = 16),
legend.key.height = unit(1.2, "cm"),
legend.key.width = unit(0.6, "cm")
)
##Employment Status##
#pull employment status from acs
employment_status <-
get_acs(
geography = "tract",
table = "B23025",
state = state_fips,
county = county_fips,
year = 2023,
survey = "acs5",
geometry = TRUE,
)
#create a new table that lists the employment status (total and share) for each tract
employment_wide_pico <- employment_status %>%
filter(GEOID %in% pico_tracts$GEOID) %>%
mutate(employment_stat = case_when(
variable == "B23025_001" ~ "total",
variable == "B23025_002" ~ "in_labor_force",
variable == "B23025_007" ~ "out_labor_force",
TRUE ~ NA_character_
)) %>%
filter(!is.na(employment_stat)) %>%
select(GEOID, employment_stat, estimate, NAME) %>%
pivot_wider(names_from = employment_stat, values_from = estimate) %>%
mutate(
share_in_labor_force = in_labor_force / total,
share_out_labor_force = out_labor_force / total
)
#calculate the totals separately
employment_total_row <- employment_wide_pico %>%
summarise(
GEOID = "Total",
total = sum(total, na.rm = TRUE),
in_labor_force = sum(in_labor_force, na.rm = TRUE),
out_labor_force = sum(out_labor_force, na.rm = TRUE)
) %>%
mutate(
share_in_labor_force = in_labor_force / total,
share_out_labor_force = out_labor_force / total
)
#bind to the original table
employment_wide_pico <- bind_rows(employment_wide_pico, employment_total_row)
#create a bar chart
employment_bar_chart <- ggplot(
tibble::tibble(
status = c("Employed", "Unemployed"),
share = c(
employment_wide_pico$share_in_labor_force[employment_wide_pico$GEOID == "Total"],
employment_wide_pico$share_out_labor_force[employment_wide_pico$GEOID == "Total"]
)
),
aes(x = status, y = share, fill = status)
) +
geom_col() +
geom_text(aes(label = scales::percent(share, accuracy = 1)), vjust = -0.5, size = 6) +
labs(
title = NULL,
x = NULL,
y = NULL,
fill = NULL
) +
scale_y_continuous(labels = NULL, breaks = NULL, expand = expansion(mult = c(0, 0.1))) +
theme(
legend.position = "none",
axis.text.x = element_text(size = 16),
axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank()
)
##Employment Status##
#pull employment status from acs
employment_status <-
get_acs(
geography = "tract",
table = "B23025",
state = state_fips,
county = county_fips,
year = 2023,
survey = "acs5",
geometry = FALSE,
)
#create a new table that lists the employment status (total and share) for each tract
employment_wide_pico <- employment_status %>%
filter(GEOID %in% pico_tracts$GEOID) %>%
mutate(employment_stat = case_when(
variable == "B23025_001" ~ "total",
variable == "B23025_002" ~ "in_labor_force",
variable == "B23025_007" ~ "out_labor_force",
TRUE ~ NA_character_
)) %>%
filter(!is.na(employment_stat)) %>%
select(GEOID, employment_stat, estimate, NAME) %>%
pivot_wider(names_from = employment_stat, values_from = estimate) %>%
mutate(
share_in_labor_force = in_labor_force / total,
share_out_labor_force = out_labor_force / total
)
#calculate the totals separately
employment_total_row <- employment_wide_pico %>%
summarise(
GEOID = "Total",
total = sum(total, na.rm = TRUE),
in_labor_force = sum(in_labor_force, na.rm = TRUE),
out_labor_force = sum(out_labor_force, na.rm = TRUE)
) %>%
mutate(
share_in_labor_force = in_labor_force / total,
share_out_labor_force = out_labor_force / total
)
#bind to the original table
employment_wide_pico <- bind_rows(employment_wide_pico, employment_total_row)
#create a bar chart
employment_bar_chart <- ggplot(
tibble::tibble(
status = c("Employed", "Unemployed"),
share = c(
employment_wide_pico$share_in_labor_force[employment_wide_pico$GEOID == "Total"],
employment_wide_pico$share_out_labor_force[employment_wide_pico$GEOID == "Total"]
)
),
aes(x = status, y = share, fill = status)
) +
geom_col() +
geom_text(aes(label = scales::percent(share, accuracy = 1)), vjust = -0.5, size = 6) +
labs(
title = NULL,
x = NULL,
y = NULL,
fill = NULL
) +
scale_y_continuous(labels = NULL, breaks = NULL, expand = expansion(mult = c(0, 0.1))) +
theme(
legend.position = "none",
axis.text.x = element_text(size = 16),
axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank()
)
##Gender##
#see sex_by_age
#pivot to take Total Male and Total Female population
gender__wide_pico <- sex_by_age %>%
filter(
variable %in% c("B01001_001", "B01001_002", "B01001_026"),
GEOID %in% pico_tracts$GEOID
) %>%
select(GEOID, variable, estimate) %>%
group_by(GEOID) %>%
summarise(
Total = sum(estimate[variable == "B01001_001"], na.rm = TRUE),
Male = sum(estimate[variable == "B01001_002"], na.rm = TRUE),
Female = sum(estimate[variable == "B01001_026"], na.rm = TRUE),
.groups = "drop"
) %>%
# Step 2: Add NAME back in from original data
left_join(
sex_by_age %>% select(GEOID, NAME) %>% distinct(),
by = "GEOID"
) %>%
mutate(
share_male = Male / Total,
share_female = Female / Total
) %>%
# Step 3: Add total row
bind_rows(
summarise(
.,
GEOID = "Total",
NAME = "Total",
Total = sum(Total, na.rm = TRUE),
Male = sum(Male, na.rm = TRUE),
Female = sum(Female, na.rm = TRUE),
share_male = sum(Male, na.rm = TRUE) / sum(Total, na.rm = TRUE),
share_female = sum(Female, na.rm = TRUE) / sum(Total, na.rm = TRUE)
)
)
ethnicity_chart_pico
gender_bar_chart_pico <- ggplot(
tibble(
status = c("Male", "Female"),
share = c(
gender__wide_pico$share_male[gender__wide_pico$GEOID == "Total"],
gender__wide_pico$share_female[gender__wide_pico$GEOID == "Total"]
)
),
aes(x = status, y = share, fill = status)
) +
geom_col() +  # Create the bars
geom_text(aes(label = scales::percent(share, accuracy = 1)), vjust = -0.5, size = 6) +  # Add percentage labels
labs(
title = NULL,
x = NULL,
y = NULL,
fill = NULL
) +
scale_y_continuous(labels = scales::percent_format(), expand = expansion(mult = c(0, 0.1))) +  # Format y-axis as percentages
theme(
legend.position = "none",  # Hide the legend
axis.text.x = element_text(size = 16),  # Customize x-axis text size
axis.text.y = element_blank(),  # Remove y-axis text (since it's already percentage)
axis.ticks.y = element_blank(),  # Remove y-axis ticks
panel.grid.major.y = element_blank(),  # Remove horizontal gridlines
panel.grid.minor.y = element_blank()  # Remove minor horizontal gridlines
)
gender_bar_chart_pico
##Family structure##
#pull family structure
family_structure <-
get_acs(
geography = "tract",
table = "B11003",
state = state_fips,
county = county_fips,
year = 2023,
survey = "acs5",
geometry = FALSE,
)
#pivot to get descriptive stats
family_bins <- list(
married_children = "B11003_003",
married_no_children = "B11003_007",
single_children = c("B11003_010", "B11003_016"),
single_no_children = c("B11003_014", "B11003_020")
)
#summarise total by family structure, for each tract
# Pivot family_structure data wider
family_wide_pico <- family_structure %>%
filter(variable %in% unlist(family_bins), GEOID %in% pico_tracts$GEOID) %>%
mutate(family_structure = case_when(
variable %in% family_bins$married_children ~ "Married with children under 18",
variable %in% family_bins$married_no_children ~ "Married without children under 18",
variable %in% family_bins$single_children ~ "Single parent with children under 18",
variable %in% family_bins$single_no_children ~ "Single parent without children under 18",
TRUE ~ NA_character_
)) %>%
filter(!is.na(family_structure)) %>%
group_by(GEOID, family_structure) %>%
summarise(population = sum(estimate, na.rm = TRUE), .groups = "drop") %>%
# Pivot the data wider to have family types as columns
pivot_wider(names_from = family_structure, values_from = population, values_fill = list(population = 0)) %>%
left_join(select(family_structure, GEOID, NAME) %>% distinct(), by = "GEOID")
#calculate the totals
family_totals <- family_wide_pico %>%
summarise(across(starts_with("Married"), ~sum(.x, na.rm = TRUE)),
across(starts_with("Single"), ~sum(.x, na.rm = TRUE))) %>%
# Reshape the data to a long format for easier analysis
pivot_longer(
cols = everything(),
names_to = "family_structure",
values_to = "population"
)
#create a bar chart
pop_by_family_type_pico <- ggplot(family_totals, aes(x = family_structure, y = population, fill = family_structure)) +
geom_col() +
geom_text(aes(label = scales::comma(population)), vjust = -0.5, size = 5) +
labs(
x = NULL,
y = "Population"
) +
scale_y_continuous(labels = scales::comma) +
scale_x_discrete(labels = function(x) str_wrap(x, width = 16)) +
theme(legend.position = "none") +
theme(
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
axis.text.x = element_text(size = 16),
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
##Limited English##
#pull from acs
language <-
get_acs(
geography = "tract",
table = "B16004",
state = state_fips,
county = county_fips,
year = 2023,
survey = "acs5",
geometry = TRUE,
)
#create bins based on the table
language_bins <- list(
very_well = c("B16004_005", "B16004_010", "B16004_015", "B16004_020", "B16004_027", "B16004_032", "B16004_037", "B16004_042", "B16004_049", "B16004_054", "B16004_059", "B16004_064"),
well = c("B16004_006", "B16004_011", "B16004_016", "B16004_021", "B16004_028", "B16004_033", "B16004_038", "B16004_043", "B16004_050", "B16004_055", "B16004_060", "B16004_065"),
not_well = c("B16004_007", "B16004_012", "B16004_017", "B16004_022", "B16004_029", "B16004_034", "B16004_039", "B16004_044", "B16004_051", "B16004_056", "B16004_061", "B16004_066"),
none =c("B16004_008", "B16004_013", "B16004_018", "B16004_023", "B16004_030", "B16004_035", "B16004_040", "B16004_045", "B16004_052", "B16004_057", "B16004_062", "B16004_067")
)
#summarise total by language, for each tract
# Pivot  data wider
language_wide_pico <- language %>%
filter(variable %in% unlist(language_bins), GEOID %in% pico_tracts$GEOID) %>%
mutate(language_skill = case_when(
variable %in% language_bins$very_well ~ "Very well",
variable %in% language_bins$well ~ "Well",
variable %in% language_bins$not_well ~ "Not well",
variable %in% language_bins$none ~ "Not at all",
TRUE ~ NA_character_
)) %>%
filter(!is.na(language_skill)) %>%
group_by(GEOID, language_skill) %>%
summarise(population = sum(estimate, na.rm = TRUE), .groups = "drop") %>%
# Pivot the data wider to have language skills as columns
pivot_wider(names_from = language_skill, values_from = population, values_fill = list(population = 0)) %>%
left_join(select(language, GEOID, NAME) %>% distinct(), by = "GEOID")
language_totals <- language_wide_pico %>%
select(-GEOID, -NAME) %>%
summarise(across(everything(), ~sum(.x, na.rm = TRUE))) %>%
pivot_longer(
cols = everything(),
names_to = "language_skill",
values_to = "population"
)
#reorder so that the bars show up in the order we want
language_totals$language_skill <- factor(
language_totals$language_skill,
levels = c("Very well", "Well", "Not well", "Not at all")
)
#repeat the above but calculating percentages
# Calculate percentages for each language skill category
language_totals_pct <- language_wide_pico %>%
select(-GEOID, -NAME) %>%
summarise(across(everything(), ~sum(.x, na.rm = TRUE))) %>%
pivot_longer(
cols = everything(),
names_to = "language_skill",
values_to = "population"
) %>%
mutate(
percent = population / sum(population)
)
# Reorder the factor levels
language_totals_pct$language_skill <- factor(
language_totals_pct$language_skill,
levels = c("Very well", "Well", "Not well", "Not at all")
)
# Plot as a percentage bar chart
pop_by_language_skill_pct_pico <- ggplot(language_totals_pct, aes(x = language_skill, y = percent, fill = language_skill)) +
geom_col() +
geom_text(aes(label = scales::percent(percent, accuracy = 1)), vjust = -0.5, size = 5) +  # Percent labels
labs(
x = NULL,
y = NULL
) +
scale_y_continuous(labels = NULL, breaks = NULL, expand = expansion(mult = c(0, 0.1))) +
scale_x_discrete(labels = function(x) str_wrap(x, width = 16)) +
theme(legend.position = "none") +
theme(
axis.title.x = element_text(size = 16),
axis.text.x = element_text(size = 16),
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
#create bins for each language spoken
language_bins_1 <- list(
total = "B16004_001",
only_english = c("B16004_003", "B16004_025", "B16004_047"),
spanish = c("B16004_004", "B16004_026", "B16004_048"),
other_indo_euro = c("B16004_009", "B16004_031", "B16004_053"),
asian_pac_island =c("B16004_014", "B16004_036", "B16004_058"),
other_language = c("B16004_19", "B16004_041", "B16004_063")
)
#summarise total by language, for each tract
# Pivot  data wider
spoken_language_wide_pico <- language %>%
filter(variable %in% unlist(language_bins_1), GEOID %in% pico_tracts$GEOID) %>%
mutate(language_spoken = case_when(
variable %in% language_bins_1$total ~ "Total",
variable %in% language_bins_1$only_english ~ "English Only",
variable %in% language_bins_1$spanish ~ "Spanish",
variable %in% language_bins_1$other_indo_euro ~ "Other Indo-European Languages",
variable %in% language_bins_1$asian_pac_island ~ "Asian and Pacific Island Languages",
variable %in% language_bins_1$other_language ~ "Other Languages",
TRUE ~ NA_character_
)) %>%
filter(!is.na(language_spoken)) %>%
group_by(GEOID, language_spoken) %>%
summarise(population = sum(estimate, na.rm = TRUE), .groups = "drop") %>%
# Pivot wider to get one column per language
pivot_wider(names_from = language_spoken, values_from = population, values_fill = list(population = 0)) %>%
mutate(
share_english_only = `English Only` / Total,
share_spanish = Spanish / Total,
share_other_indo_euro = `Other Indo-European Languages` / Total,
share_asian_pac_island = `Asian and Pacific Island Languages` / Total,
share_other_language = `Other Languages` / Total
) %>%
left_join(select(language, GEOID, NAME) %>% distinct(), by = "GEOID")
language_spoken_totals <- spoken_language_wide_pico %>%
select(-GEOID, -NAME) %>%
summarise(across(everything(), ~sum(.x, na.rm = TRUE))) %>%
pivot_longer(
cols = everything(),
names_to = "language_spoken",
values_to = "population"
)
spanish_map_pico <- ggplot(spoken_language_wide_pico_sf) +
geom_sf(aes(fill = share_spanish), show.legend = TRUE) +
#add the buffer overlay
geom_sf(data = pico_buffer_tracts, color = "yellow", alpha = 0.2, lwd = 1) +
#add the street overlay
geom_sf(data = major_streets_clipped, color = "gray20", size = 0.3) +
scale_fill_gradientn(
colors = palette_urbn_magenta[c(1, 3, 5, 7)],
name = NULL,
labels = scales::percent_format()
) +
theme_urbn_map()+
theme(
legend.title = element_text(size = 16),
legend.text = element_text(size = 16),
legend.key.height = unit(1.2, "cm"),
legend.key.width = unit(0.6, "cm")
)
#create map with points overlaid
crash_map_pico <- ggplot() +
geom_sf(data = pico_buffer_tracts, fill = "lightgray", color = "gray40", size = 0.3) +
geom_sf(data = major_streets_clipped, color = "orange", size = 0.6) +
geom_sf(data = crashes_pico_sf, color = "red", size = 1, alpha = 0.7) +
# labs(title = "Crash Locations in Pico Area",
#      subtitle = "Overlaid on Buffer Tracts and Major Streets",
#      caption = "Source: TIMS") +
theme_urbn_map()+
theme(
plot.title = element_text(face = "bold", size = 14),
plot.subtitle = element_text(size = 12)
)
crash_map_pico
